<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | Charles Hooper]]></title>
  <link href="http://www.charleshooper.net/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://www.charleshooper.net/"/>
  <updated>2015-05-24T07:49:52-07:00</updated>
  <id>http://www.charleshooper.net/</id>
  <author>
    <name><![CDATA[Charles Hooper]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Painless instrumentation of Celery tasks using statsd and graphite]]></title>
    <link href="http://www.charleshooper.net/blog/painless-instrumentation-of-celery-tasks-using-statsd-and-graphite/"/>
    <updated>2012-03-12T00:00:00-07:00</updated>
    <id>http://www.charleshooper.net/blog/painless-instrumentation-of-celery-tasks-using-statsd-and-graphite</id>
    <content type="html"><![CDATA[<h1 id="section"></h1>

<p><img src="http://www.charleshooper.net/wp-content/uploads/400px-Steuerstand01-150x150.jpg" alt="" title="A Control Station" />
For one of my clients and side projects, we’ve been working hard to build in application-level metrics to our wide portfolio of services. Among these services is one built on top of the <a href="http://celeryproject.org/">Celery distributed task queue</a>. We wanted a system that required as little configuration as possible to publish new metrics. For this reason, we decided on using <a href="http://codeascraft.etsy.com/2011/02/15/measure-anything-measure-everything/">statsd</a> and <a href="http://graphite.wikidot.com/">graphite</a>. Getting statsd and graphite running was the easy part, but we needed a quick, painless way of adding the instrumentation code for the most basic metrics to our Celery-backed service.</p>

<p>For us, those basic metrics consisted of:</p>

<ul>
  <li>Number of times a worker starts on a specific task</li>
  <li>Number of times a task raises an exception</li>
  <li>Number of times a task completes successfully (no exceptions)</li>
  <li>How long each task takes to complete</li>
</ul>

<p>Since the code to enable these metrics just <em>wraps</em> the code being instrumented it seemed only natural to use a decorator. Below is the code I wrote to do just that.</p>

<p>{% codeblock statsd_instrument.py https://gist.github.com/chooper/2018362 %}</p>

<p>”"”Decorator to quickly add statsd (graphite) instrumentation to Celery
task functions.</p>

<p>With some slight modification, this could be used to instrument just
about any (non-celery) function and be made abstract enough to customize
metric names, etc.</p>

<p>Stats reported include number of times the task was accepted by a worker
(<code>started</code>), the number of successes, and the number of times the task
raised an exception. In addition, it also reports how long the task took
to complete. Usage:</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>@task
@instrument_task
def mytask():
    # do stuff
    pass</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>Please note that the order of decorators is important to Celery. See
http://ask.github.com/celery/userguide/tasks.html#decorating-tasks
for more information.</p>

<p>Uses <code>simple_decorator</code> from
http://wiki.python.org/moin/PythonDecoratorLibrary#Property_Definition</p>

<p>Limitation: Does not readily work on subclasses of celery.tasks.Task
because it always reports <code>task_name</code> as ‘run’
“””</p>

<h1 id="statsd-instrumentation">statsd instrumentation</h1>
<p>from celery import current_app
import statsd</p>

<p>@simple_decorator
def instrument_task(func):
    “"”Wraps a celery task with statsd instrumentation code”””</p>

<pre><code>def instrument_wrapper(*args, **kwargs):
    stats_conn = statsd.connection.Connection(
        host = current_app.conf['STATSD_HOST'],
        port = current_app.conf['STATSD_PORT'],
        sample_rate = 1)

    task_name = func.__name__

    counter = statsd.counter.Counter('celery.tasks.status',stats_conn)
    counter.increment('{task_name}.started'.format(**locals()))

    timer = statsd.timer.Timer('celery.tasks.duration', stats_conn)
    timer.start()

    try:
        ret = func(*args, **kwargs)
    except:
        counter.increment('{task_name}.exceptions'.format(**locals()))
        raise
    else:
        counter.increment('{task_name}.success'.format(**locals()))
        timer.stop('{task_name}.success'.format(**locals()))
        return ret
    finally:
        try:
            del timer
            del counter
            del stats_conn
        except:
            pass

return instrument_wrapper
</code></pre>

<p>def simple_decorator(decorator):
    “"”Borrowed from:
    http://wiki.python.org/moin/PythonDecoratorLibrary#Property_Definition</p>

<pre><code>Original docstring:
This decorator can be used to turn simple functions
into well-behaved decorators, so long as the decorators
are fairly simple. If a decorator expects a function and
returns a function (no descriptors), and if it doesn't
modify function attributes or docstring, then it is
eligible to use this. Simply apply @simple_decorator to
your decorator and it will automatically preserve the
docstring and function attributes of functions to which
it is applied."""
def new_decorator(f):
    g = decorator(f)
    g.__name__ = f.__name__
    g.__module__ = f.__module__ # or celery throws a fit
    g.__doc__ = f.__doc__
    g.__dict__.update(f.__dict__)
    return g
# Now a few lines needed to make simple_decorator itself
# be a well-behaved decorator.
new_decorator.__name__ = decorator.__name__
new_decorator.__doc__ = decorator.__doc__
new_decorator.__dict__.update(decorator.__dict__)
return new_decorator
</code></pre>

<p>{% endcodeblock %}</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Couple of Python Snippets]]></title>
    <link href="http://www.charleshooper.net/blog/a-couple-of-python-snippets/"/>
    <updated>2011-06-30T00:00:00-07:00</updated>
    <id>http://www.charleshooper.net/blog/a-couple-of-python-snippets</id>
    <content type="html"><![CDATA[<h1 id="section"></h1>

<p>I haven’t updated in awhile but I decided to drop a couple of gists in here and call it a post. These snippets are incredibly simple and I don’t expect to “wow” anybody here, but I was asked for them recently and am posting them here.</p>

<h1 id="group-words-by-their-first-letter-in-python">Group words by their first letter in Python</h1>

<p>{% codeblock group_by_letter.py https://gist.github.com/chooper/1050517#file-group_by_letter-py %}
#!/usr/bin/env python</p>

<p>”"”Group words by their first letter”””</p>

<p>from collections import defaultdict</p>

<p>def group_by_letter(words):
    buckets = defaultdict(lambda:[])
    for word in words:
        buckets[word[0].lower()].append(word)
    return buckets</p>

<p>if <strong>name</strong> == ‘<strong>main</strong>’:
    print group_by_letter([‘narragansett’,’brooklyn lager’,’magic
hat’,’dog fish head’,’shock top’,’ten penny’,’bass’])
    # Output: defaultdict(&lt;function <lambda> at 0x7fc83416b2a8&gt;, {'b':
    # ['bass', 'brooklyn lager'], 'd': ['dog fish head'], 'm': ['magic
    # hat'], 'n':['narragansett'], 's': ['shock top'], 't': ['ten
    # penny']})
{% endcodeblock %}</lambda></p>

<h1 id="merging-list-of-lists-in-python-using-reduce">Merging list of lists in Python using reduce</h1>

<p>{% codeblock merge_lists.py https://gist.github.com/chooper/1054819#file-merge_lists-py %}</p>

<h1 id="usrbinenv-python">!/usr/bin/env python</h1>

<p>”"”Merging list of lists in Python using reduce()”””</p>

<p>def merge_lists(list_of_lists):
    return reduce(lambda x,y: x+y, list_of_lists)</p>

<p>if <strong>name</strong> == ‘<strong>main</strong>’:
    my_big_list = [ [1,2,3], [3,4,5], [6,7,8], ]
    print merge_lists(my_big_list)
    # output: [1, 2, 3, 3, 4, 5, 6, 7, 8]</p>

<p>{% endcodeblock %}</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automating Webcam Snapshots and Uploads to Flickr]]></title>
    <link href="http://www.charleshooper.net/blog/automating-webcam-snapshots-and-uploads-to-flickr/"/>
    <updated>2011-03-26T00:00:00-07:00</updated>
    <id>http://www.charleshooper.net/blog/automating-webcam-snapshots-and-uploads-to-flickr</id>
    <content type="html"><![CDATA[<h1 id="section"></h1>

<p>With gardening season right around the corner, one of my desires was to set something up that would allow me to take automated, regular snapshots of some of my plants and upload them to flickr. After a few cumulative hours I finally cobbled together the solution.</p>

<h2 id="taking-the-snapshots">Taking the Snapshots</h2>

<p>The first thing I needed to do was to take snapshots from an installed USB webcam and save them to a directory. This needed to be able to run from a cron script so obviously it needed to work without a GUI and without user-interaction. I read in a <a href="http://www.tldp.org/HOWTO/html_single/Webcam-HOWTO/#COMMAND">Webcam Howto</a> that I could do this using <strong>streamer</strong> so I installed it and wrote a short shell script that would iterate through the video devices installed on my PC and run the snapshot command. You can <a href="https://bitbucket.org/hoop/snapshot/src/98aa5d9a2038/snapshot">view the source of this script here</a>.</p>

<h2 id="uploading-the-photos">Uploading the Photos</h2>

<p>Next I wanted to automatically upload the files to Flickr. At first, I tried using a script I found called uploadr.py which worked OK, but I also wanted to add my photos to a specific set which this script didn’t do. I probably could have extended its functionality, but this script didn’t use or implement the full Flickr API which made this task seem unnecessary.</p>

<p>Instead, I downloaded the <a href="http://stuvel.eu/flickrapi">Python Flickr API from Stuvel</a> and in less than 90 lines I had working code to upload a directory of images to Flickr and add them to a given set. You can view the source to my <a href="https://bitbucket.org/hoop/snapshot/src/98aa5d9a2038/simpleuploadr.py">flickr uploader script</a> here, which I’m calling <a href="https://bitbucket.org/hoop/snapshot">simpleuploadr.py</a> for now.</p>

<h2 id="results">Results</h2>

<p><a href="http://www.flickr.com/photos/hoop2w1/sets/72157626354700156/with/5620672632/">Here are my pretty pictures</a> :) My apologies for the quality, I’m using a really cheap webcam.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Going into Business? Learn a Programming Language]]></title>
    <link href="http://www.charleshooper.net/blog/going-into-business-learn-a-programming-language/"/>
    <updated>2010-11-15T00:00:00-08:00</updated>
    <id>http://www.charleshooper.net/blog/going-into-business-learn-a-programming-language</id>
    <content type="html"><![CDATA[<h1 id="section"></h1>

<p>When doing homework for my business-related classes, I often find that knowing a programming language is very advantageous. Certainly there are times when it makes sense to use a calculator, but repeatedly entering the same equation over and over is tedious and inefficient. There are also times when it’s a good idea to make a spreadsheet, but even this can be overkill.</p>

<p>In cases where I’m repeating the same tasks or expressions frequently and a spreadsheet seems like overkill, I’ll open a Python shell and define the expression I need as a function. More often than not, these functions are one liners that I probably won’t use again. At least, not until I get a “Real Job (TM)” where I’ll need to use said expressions more frequently.</p>

<p>As an example, I recently found myself calculating the gains and/or losses between two given foreign exchange rates. The example below calculates the gain or loss between two period’s exchange rates for a given currency.</p>

<pre><code>def xchg_diff(qty,old_rate,new_rate):
    """
    qty = Amount of 'domestic currency'
    old_rate = Exchange rate of foreign currency in previous period
    new_rate = Exchange rate of foreign currency in current period
    """
    return round(qty * (new_rate - old_rate))
</code></pre>

<p>In this example, the hypothetical company had 850,000 pesos that it held over multiple accounting periods. I was given a table of dates that corresponded with these accounting periods and the exchange rate of pesos to U.S. Dollars (USD $) that looked similar to the one below.</p>

<p>Date</p>

<p>Exchange Rate</p>

<p>Mar 31, 2009</p>

<p>0.0698</p>

<p>Jun 30, 2009</p>

<p>0.0756</p>

<p>Sep 30, 2009</p>

<p>0.0737</p>

<p>Dec 31, 2009</p>

<p>0.0777</p>

<p>The equation is simple enough to type into a calculator, but I find most calculators to have a clumsy interface when it comes to editing the numbers in previous expressions. In this case, I simply opened up a Python shell and, after defining the above function, I typed:</p>

<pre><code>&gt;&gt;&gt; xchg_diff(850000,0.0698,0.0756)
4930.0
&gt;&gt;&gt; xchg_diff(850000,0.0756,0.0737)
-1615.0
&gt;&gt;&gt; xchg_diff(850000,0.0737,0.0777)
3400.0
</code></pre>

<p>As we can see from the transcript, I was quickly able to find the following results:</p>

<p>Date</p>

<p>Gain / (loss)</p>

<p>Jun 30, 2009</p>

<p>$4930</p>

<p>Sep 30, 2009</p>

<p>$(1615)</p>

<p>Dec 31, 2009</p>

<p>$3400</p>

<p>Many people have asked me if I thought that my experience in computers and programming would go to waste once I entered the world of business and, in particular, finance. My response has been, and will continue to be, “No.” Knowing how to automate routine tasks, being able to write data models, and having a firm grasp on algorithms will only help me to be more effective in my future career.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Validating Data with New-Style Classes in Python]]></title>
    <link href="http://www.charleshooper.net/blog/validating-data-with-new-style-classes-in-python/"/>
    <updated>2010-10-11T00:00:00-07:00</updated>
    <id>http://www.charleshooper.net/blog/validating-data-with-new-style-classes-in-python</id>
    <content type="html"><![CDATA[<h1 id="section"></h1>

<p>Every once in awhile in my reading I come across a minor reference to what pythonistas refer to as <strong>new-style classes</strong>. One of the nice things about new-style classes is the `property` decorators. These property decorators allow you to build getter and setter methods to access object attributes. This is pretty awesome because now you can perform validation at the model/class level whenever you assign a value to a property of an object.</p>

<p>e.g., In one of my projects, I have an attribute named <em>timestamp</em> that takes a `datetime` object. I was concerned about receiving incorrect types from my input because there are alot of ways a programmer can represent the concept of time. Some realistic possibilities of invalid types in my case are:</p>

<ul>
  <li>`time` objects from the time module</li>
  <li>`string` objects that contain the date and time (and various possible formats)</li>
  <li>`float` or `int` objects that contain a unix timestamp</li>
</ul>

<p>With a setter method, you can test that the new value being assigned to an attribute is the correct type before assigning it. You can also throw an <strong>exception</strong> if it’s not. In other words, you can do something like this:</p>

<pre><code>from datetime import datetime

class SomeObject(object):    # new-style classes must be subclassed from object
    _timestamp = None

    @property
    def timestamp(self):
        return self._timestamp

    @timestamp.setter    # the prefix must match the read-only getter func name
    def timestamp(self,value):    # the func name must match the read-only getter func name
        if not isinstance(value, datetime):
            raise ValueError(“Timestamp can only be an instance of Datetime”)
        self._timestamp = value
</code></pre>

<p>Go ahead and try it!</p>
]]></content>
  </entry>
  
</feed>
